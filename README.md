# Завдання 1

## Умова:

Скільки пам’яті може виділити malloc(3) за один виклик?

Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це
максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти.
Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на
x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

## [Програмний код](1.c)

## Опис:

Написаний код демонструє як можна визначити максимальний об'єм пам'яті, що може за раз аллокувати malloc(3). Запускаючи програму на
64-бітній архітектурі, тобто на x86_64 бачимо, що максимальний об'єм становитиме 2^64, або 18446744073709551615 байтів, або 16
екзабайт, оскільки це є максимальним значенням size_t. Програма визначає кількість біт у size_t через sizeof(size_t), через що при
запуску на x86, тобто 32 бітній архітектурі, sizeof поверне не 8, а 4, через що результат отримуємо відповідно 2^32, або 4294967296
байтів. Теоретично максимальний обсяг пам'яті на 64 бітній системі складає 8, ф не 16 ЕБ через розподіл адресного простору, половина
якого виділена під користувацькі програми, тобто 8 ЕБ, а інша половина виділена під ядро (user space та kernel space).
Для отримання 32 бітного виконуваного файлу при коспіляції після "gcc" додано аргумент -m32.

## Результат виконання:

### x86_64:

```
Bits in size_t: 64
Max size_t (2^64): 18446744073709551615 bytes
malloc(3) can allocate 16 EB or 18446744073709551615 B max
```

### x86:

```
Bits in size_t: 32
Max size_t (2^32): 4294967295 bytes
malloc(3) can allocate 0 EB or 4294967295 B max
```

# Завдання 2

## Умова:

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за
формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення?
Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

## [Програмний код](2.c)

## Опис:

Створено програму з функцією xa_xb(), що приймай 2 аргументи (xa та xb), множить іх і результат записує у цілочисельну змінну зі знаком
num. Ця змінна також переводиться у беззнаковий size_t варіант виключно для відображення значення, на яке malloc(3) перетворює переданий
у нього int. Спочатку протстовано відносно малі значення, але потім за xa та xb взято максимальне значення int та 2 відповідно, що
призводить до переповнення int num аж до -2. malloc(3), приймаюче від'ємне значення, конвертує його в беззнаковий варіант, що призводить
до переповнення, але вже у іншому напрямку: при відніманні від нуля беззнакового значення, воно повертається до свого максимального
значення і віднімає від нього. Так як маємо -2, malloc(3) його конвертує у дуже велике додатнє значення без знаку, яке звісно аллокувати
не може, через що і відповідне повідомлення. Раніше згадана конвертація у size_t саме для того, що побачити, у яке значення malloc(3)
конвертує отримане переповнене знакове від'ємне значення. Через використання INT_MAX з limits.h, на 32 бітній системі num також
переповнюється до -2, але от size_t варіант вже є іншим. Максимальні значення size_t для 32 і 64 біт:
- x86_64: 18446744073709551615
- x86: 4294967295

## Результат виконання:

### x86_64:

```
xa: 100, xb: 200
num: 20000
num_sizet = 20000
Allocated 20000 bytes

xa: 2147483647, xb: 2
num: -2
num_sizet = 18446744073709551614
Didn't allocate 18446744073709551614 bytes
```

### x86:

```
xa: 100, xb: 200
num: 20000
num_sizet = 20000
Allocated 20000 bytes

xa: 2147483647, xb: 2
num: -2
num_sizet = 4294967294
Didn't allocate 4294967294 bytes
```

# Завдання 3

## Умова:

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і
який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

## [Програмний код](3.c)

## Опис:

Написано простий код, що аллокує пам'ять церез malloc(0), та перевіряє чи повертається NULL або якесь значення. Після компіляції та
запуску з ltrace, який потрібно було встановити, проаналізуючи вивід можна зрозуміти що:
- malloc(0) повернув не NULL вказівник який передався у printf()
- free() зміг звільнити цей вказівник успішно (в кінці написано = <void>, значить без помилок)
- status 0 значить, що програма закінчилась нормально

Взагалі поведінка програми при malloc(0) невизначена, тому і сказано що можна отримати як NULL, так і якусь адресу. Компілятор не
ставить якихось запобіжних бар'єрів і не забороняє алокацію нуля, через що використання такої функції краще уникати. У випадку
повернення malloc(0) вказівника, його можна буде безпечно передавати у free(), аде не можна буде дереференсувати.

## Результат виконання:

```
Couldn't determine base address of [vdso]
Couldn't load ELF object [vdso]: No such file or directory
__libc_start1(1, 0x821216098, 0x8212160a8, 0x2aadaf0d2cc0, 0x400652 <unfinished ...>
malloc(0)                                                                                                           = 0x1a6b5a408008
printf("Returned pointer: %p\n", 0x1a6b5a408008Returned pointer: 0x1a6b5a408008
)                                                                    = 33
free(0x1a6b5a408008)                                                                                                = <void>
+++ exited (status 0) +++
```

# Завдання 4

## Умова:

Чи є помилки у такому коді?
```
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
```
Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

## Програмний код:

### [Проблема](4-1.c)

### [Правильний варіант](4-2.c)

## Опис:

У написаному помилковому коді під час першої ітерації циклу умова !ptr виконується, тому алокується пам'ять і в неї
щось записується (тут - літера "e"), а далі пам'ять звільняється. На другій ж ітерації умова !ptr не виконується, оскільки звільнений
вказівник не є NULL, тому пам'ять у нього не алокується. Проте далі він знов використовується для запису, що приводить до невизначеної
поведінки (у наданому результаті виконання - програма спиняється). Така ситуація навіть має назву - UAF (use after free), коли пам'ять
використовується після її звільнення. Найпростішим способом цей код виправити буде повертати значення ptr до NULL у кінці кожної
ітерації після звільнення пам'яті. Таким чином (!ptr) виконуватиметься і пам'ять виділятиметься знову щоразу.

## Результат виконання:

### Проблемна програма:

```
1. ptr: 0x15f3a6209000
```

### Виправлена програма:

```
1. ptr: 0x3f2251208008
2. ptr: 0x3f2251208008
3. ptr: 0x3f2251208008
```

# Завдання 5

## Умова:

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

## [Програмний код](5.c)

## Опис:

Написано програму, яка алокує 10 байтів у вказівник ptr, після чого намагається перевиділити його у ptr1 за допомогою realloc() та
дуже великою кількістю пам'яті (size_t)-1, тобто максимальне значення size_t, через що realloc звісно не може виділити пам'ять.
В такому випадку можна спостерігати те, що realloc() повертає NULL, тобто (!ptr1) виконується у програмі і виводиться відповідне
повідомлення. Також вказівник ptr (початковий) залишається незміненим, та має теж саме значення, що і до невдалого realloc().

## Результат виконання:

```
Allocated 10 bytes
ptr: 0x2703b8809000
Didn't realloc to ptr1
ptr: 0x2703b8809000
```

# Завдання 6

## Умова:

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.

## [Програмний код](6.c)

## Опис:

У створеній програмі виділяється пам'ять для ptr за допомогою realloc(NULL, 10), що має працювати ідентично до malloc(10), тому
результати та їх обробка далі відповідні (перевірка, чи вицшло віиділити пам'ять). У випадку ж з realloc(ptr, 0), проблема
невизнченої поведінки програми по відношенню до результубчого значення вказівника ptr1, у який іде перевиділення, є аналогічною
до проблеми з malloc(0), яка була роз'яснена [у завданні 3](#Опис-2), а от ptr в цьому випадку прочто звільняється, тобто все
ще вказує на ту ж саму адресу, але вона не вказує на валідний, виділений для цієї програми блок пам'яті.

## Результат виконання:

```
Reallocated ptr with NULL: 0x23569e09000
realloc with 0 size ptr1 is 0x23569e08008

```

# Завдання 7

## Умова:

Перепишіть наступний код, використовуючи reallocarray(3):
```
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));
```
Порівняйте результати виконання з використанням ltrace.

## [Програмний код](7.c)

## Опис:

Створено програму, що використовує наданий код, але з функцією reallocarray(3) замість realloc. reallocarray(ptr, nmemb, size)
(nmemb - number of members) є безпечнішою за realloc(ptr, size), бо при обрахуванні nmemb*size вона перевіряє на integer overflow.
При запуску з ltrace можна побачити адреси вказівників ptr та newptr не тільки там, де вони виводяться через printf, але й там, де
вони використовуються, наприклад free(0x387577c1e000). Також з calloc(1000, 8) видно, що sbar займає 8 байтів, бо має 2 int по 4.

## Результат виконання:

### Без використання ltrace:

```
Callocated ptr: 0x38b758609000
Reallocarray'd newptr: 0x38b75861e000
```

### З використанням ltrace:

```
Couldn't determine base address of [vdso]
Couldn't load ELF object [vdso]: No such file or directory
__libc_start1(1, 0x82130d340, 0x82130d350, 0x3f78cc5c3cc0, 0x400712 <unfinished ...>
calloc(1000, 8)                                                                                                     = 0x387577c09000
printf("Callocated ptr: %p\n", 0x387577c09000Callocated ptr: 0x387577c09000
)                                                                      = 31
reallocarray(0x387577c09000, 500, 8, 0x65ea0d7eb9e31f9d, 0x822441618)                                               = 0x387577c1e000
printf("Reallocarray'd newptr: %p\n", 0x387577c1e000Reallocarray'd newptr: 0x387577c1e000
)                                                               = 38
free(0x387577c1e000)                                                                                                = <void>
+++ exited (status 0) +++

```

# Завдання 8 за варіантом 18

## Умова:

Використайте mmap() для створення пам’яті, яку не звільняє ОС після завершення програми.

## Програмний код:

### [Програма запису](8-1.c)

### [Програма зчитування](8-2.c)

## Опис:

Створено дві програми для запису та зчитування пам'яті, яку не звільняє ОС після завершення програми за допомогою mmap(). Перша програма
відкриває спільну мапу (shm - shared map), за допомогою shm_open(), яка повертає file_d - файловий дескриптор, по суті ціле число для
доступу до файлу. Далі ftruncate() задає розмір файлу у 100 байтів, далі за допомогою mmap() в режимі читання/писання у спільну мапу
за її файловим дескриптором вписується текст (тут - "Immovable object"), перевіряється результат запису і файл/shared мапа закривається.
Друга програма перевіряє існування мапи, а далі подібним чином з mmap(), але в режимі тільки читання, відкриває файл після закінчення
роботи попередньої програми, виводить вміст, після чого від'єднує спільну мапу.

## Результат виконання:

```
max@aspz:~/c/4 $ ./8-2
Nothing to read
max@aspz:~/c/4 $ ./8-1
Wrote: Immovable object
max@aspz:~/c/4 $ ./8-2
Read: Immovable object
Shared map is no more
max@aspz:~/c/4 $ ./8-2
Nothing to read
```
